<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libcppa: Message handling.</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Message handling.</div>  </div>
</div>
<div class="contents">
<p>This is the beating heart of <code>libcppa</code>. Actor programming is all about message handling.</p>
<p>A message in <code>libcppa</code> is a n-tuple of values (with size &gt;= 1). You can use almost every type in a messages.</p>
<h2><a class="anchor" id="Send"></a>
Send messages</h2>
<p>The function <code>send</code> could be used to send a message to an actor. The first argument is the receiver of the message followed by any number of values. <code>send</code> creates a tuple from the given values and enqueues the tuple to the receivers mailbox. Thus, send should <b>not</b> be used to send a message to multiple receivers. You should use the <code>enqueue</code> member function of the receivers instead as in the following example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// spawn some actors</span>
 <span class="keyword">auto</span> a1 = <a class="code" href="namespacecppa.html#a4dbdefa108d37aaaf224a716016c3753" title="Spawns a new actor that executes what with given arguments.">spawn</a>(...);
 <span class="keyword">auto</span> a2 = <a class="code" href="namespacecppa.html#a4dbdefa108d37aaaf224a716016c3753" title="Spawns a new actor that executes what with given arguments.">spawn</a>(...);
 <span class="keyword">auto</span> a3 = <a class="code" href="namespacecppa.html#a4dbdefa108d37aaaf224a716016c3753" title="Spawns a new actor that executes what with given arguments.">spawn</a>(...);

 <span class="comment">// send a message to a1</span>
 <a class="code" href="namespacecppa.html#a1e0690c8df96f321e39dd8cac1269e7f" title="Sends a message to whom.">send</a>(a1, atom(<span class="stringliteral">&quot;hello&quot;</span>), <span class="stringliteral">&quot;hello a1!&quot;</span>);

 <span class="comment">// send a message to a1, a2 and a3</span>
 <span class="keyword">auto</span> msg = <a class="code" href="group___implicit_conversion.html#gabd9c269d41c986f38dbb1145a65d1935" title="Creates a new tuple from args.">make_tuple</a>(atom(<span class="stringliteral">&quot;compute&quot;</span>), 1, 2, 3);
 <span class="keyword">auto</span> s = <span class="keyword">self</span>(); <span class="comment">// cache self() pointer</span>
 <span class="comment">// note: this is more efficient then using send() three times because</span>
 <span class="comment">//       send() would create a new tuple each time;</span>
 <span class="comment">//       this safes both time and memory thanks to libcppa&#39;s copy-on-write</span>
 a1-&gt;enqueue(s, msg);
 a2-&gt;enqueue(s, msg);
 a3-&gt;enqueue(s, msg);

 <span class="comment">// modify msg and send it again</span>
 <span class="comment">// (msg becomes detached due to copy-on-write optimization)</span>
 get_ref&lt;1&gt;(msg) = 10; <span class="comment">// msg is now { atom(&quot;compute&quot;), 10, 2, 3 }</span>
 a1-&gt;enqueue(s, msg);
 a2-&gt;enqueue(s, msg);
 a3-&gt;enqueue(s, msg);
</pre></div><h2><a class="anchor" id="Receive"></a>
Receive messages</h2>
<p>The function <code>receive</code> takes a  behavior as argument. The behavior is a list of { pattern &gt;&gt; callback } rules.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="namespacecppa.html#ad070b8b4e3991e430c653f96b5717c78" title="Dequeues the next message from the mailbox.">receive</a>
 (
     on&lt;atom(<span class="stringliteral">&quot;hello&quot;</span>), std::string&gt;() &gt;&gt; [](<span class="keyword">const</span> std::string&amp; msg)
     {
         cout &lt;&lt; <span class="stringliteral">&quot;received hello message: &quot;</span> &lt;&lt; msg &lt;&lt; endl;
     },
     on&lt;atom(<span class="stringliteral">&quot;compute&quot;</span>), int, int, <span class="keywordtype">int</span>&gt;() &gt;&gt; [](<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)
     {
         <span class="comment">// send our result back to the sender of this messages</span>
         reply(atom(<span class="stringliteral">&quot;result&quot;</span>), i0 + i1 + i2);
     }
 );
</pre></div><p>The function <code>on</code> creates a pattern. It provides two ways of defining patterns: either by template parameters (prefixed by up to four atoms) or by arguments. The first way matches for types only (exept for the prefixing atoms). The second way compares values. Use the template function <code>val</code> to match for the type only.</p>
<p>This example is equivalent to the previous one but uses the second way to define patterns:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="namespacecppa.html#ad070b8b4e3991e430c653f96b5717c78" title="Dequeues the next message from the mailbox.">receive</a>
 (
     on(atom(<span class="stringliteral">&quot;hello&quot;</span>), val&lt;std::string&gt;()) &gt;&gt; [](<span class="keyword">const</span> std::string&amp; msg)
     {
         cout &lt;&lt; <span class="stringliteral">&quot;received hello message: &quot;</span> &lt;&lt; msg &lt;&lt; endl;
     },
     on(atom(<span class="stringliteral">&quot;compute&quot;</span>), val&lt;int&gt;(), val&lt;int&gt;(), val&lt;int&gt;()&gt;() &gt;&gt; [](<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)
     {
         <span class="comment">// send our result back to the sender of this messages</span>
         reply(atom(<span class="stringliteral">&quot;result&quot;</span>), i0 + i1 + i2);
     }
 );
</pre></div><h2><a class="anchor" id="Atoms"></a>
Atoms</h2>
<p>Atoms are a nice way to add semantic informations to a message. Assuming an actor wants to provide a "math sevice" for integers. It could provide operations such as addition, subtraction, etc. This operations all have two operands. Thus, the actor does not know what operation the sender of a message wanted by receiving just two integers.</p>
<p>Example actor: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> math_actor()
 {
     <a class="code" href="namespacecppa.html#a6728e2b69360dda2a561753bcb742b39" title="Receives messages in an endless loop.">receive_loop</a>
     (
         on&lt;atom(<span class="stringliteral">&quot;plus&quot;</span>), <span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt;() &gt;&gt; [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)
         {
             reply(atom(<span class="stringliteral">&quot;result&quot;</span>), a + b);
         },
         on&lt;atom(<span class="stringliteral">&quot;minus&quot;</span>), int, <span class="keywordtype">int</span>&gt;() &gt;&gt; [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)
         {
             reply(atom(<span class="stringliteral">&quot;result&quot;</span>), a - b);
         }
     );
 }
</pre></div><h2><a class="anchor" id="ReceiveLoops"></a>
Receive loops</h2>
<p>Previous examples using <code>receive</code> create behavior on-the-fly. This is inefficient in a loop since the argument passed to receive is created in each iteration again. Its possible to store the behavior in a variable and pass that variable to receive. This fixes the issue of re-creation each iteration but rips apart definition and usage.</p>
<p>There are three convenience function implementing receive loops to declare patterns and behavior where they belong without unnecessary copies: <code>receive_loop</code>, <code>receive_while</code> and <code>do_receive</code>.</p>
<p><code>receive_loop</code> is analogous to <code>receive</code> and loops "forever" (until the actor finishes execution).</p>
<p><code>receive_while</code> creates a functor evaluating a lambda expression. The loop continues until the given returns false. A simple example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// receive two ints</span>
 vector&lt;int&gt; received_values;
 <a class="code" href="namespacecppa.html#a04248d8185833939eccbf45a0598fff7" title="Receives messages as long as stmt returns true.">receive_while</a>([&amp;]() { <span class="keywordflow">return</span> received_values.size() &lt; 2; })
 (
     on&lt;int&gt;() &gt;&gt; [](<span class="keywordtype">int</span> value)
     {
         received_values.push_back(value);
     }
 );
 <span class="comment">// ...</span>
</pre></div><p><code>do_receive</code> returns a functor providing the function <code>until</code> that takes a lambda expression. The loop continues until the given lambda returns true. Example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// receive ints until zero was received</span>
 vector&lt;int&gt; received_values;
 <a class="code" href="namespacecppa.html#ab33b8657e1fdb052219c271a198c1854" title="Receives messages until stmt returns true.">do_receive</a>
 (
     on&lt;int&gt;() &gt;&gt; [](<span class="keywordtype">int</span> value)
     {
         received_values.push_back(value);
     }
 )
 .until([&amp;]() { <span class="keywordflow">return</span> received_values.back() == 0 });
 <span class="comment">// ...</span>
</pre></div><h2><a class="anchor" id="FutureSend"></a>
Send delayed messages</h2>
<p>The function <code>future_send</code> provides a simple way to delay a message. This is particularly useful for recurring events, e.g., periodical polling. Usage example:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="namespacecppa.html#af9614d93dea8b994164ebe41d8b1c940" title="Sends a message to whom that is delayed by rel_time.">future_send</a>(<span class="keyword">self</span>(), std::chrono::seconds(1), atom(<span class="stringliteral">&quot;poll&quot;</span>));
 <a class="code" href="namespacecppa.html#a6728e2b69360dda2a561753bcb742b39" title="Receives messages in an endless loop.">receive_loop</a>
 (
     <span class="comment">// ...</span>
     on&lt;atom(<span class="stringliteral">&quot;poll&quot;</span>)&gt;() &gt;&gt; []()
     {
         <span class="comment">// ... poll something ...</span>
         <span class="comment">// and do it again after 1sec</span>
         <a class="code" href="namespacecppa.html#af9614d93dea8b994164ebe41d8b1c940" title="Sends a message to whom that is delayed by rel_time.">future_send</a>(<span class="keyword">self</span>(), std::chrono::seconds(1), atom(<span class="stringliteral">&quot;poll&quot;</span>));
     }
 );
</pre></div> </div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 7 2011 23:29:48 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
