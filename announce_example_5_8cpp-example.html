<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libcppa: announce_example_5.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">announce_example_5.cpp</div>  </div>
</div>
<div class="contents">
<p>An advanced example for <code>announce</code> implementing serialization for a user-defined tree data type.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/******************************************************************************</span>
<span class="comment"> * This example shows how to implement serialize/deserialize to announce      *</span>
<span class="comment"> * non-trivial data structures to the libcppa type system.                    *</span>
<span class="comment"> *                                                                            *</span>
<span class="comment"> * Announce() auto-detects STL compliant containers and provides              *</span>
<span class="comment"> * an easy way to tell libcppa how to serialize user defined types.           *</span>
<span class="comment"> * See announce_example 1-4 for usage examples.                               *</span>
<span class="comment"> *                                                                            *</span>
<span class="comment"> * You should use &quot;hand written&quot; serialize/deserialize implementations        *</span>
<span class="comment"> * if and only if there is no other way.                                      *</span>
<span class="comment"> ******************************************************************************/</span>

<span class="preprocessor">#include &lt;cstdint&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &quot;cppa/cppa.hpp&quot;</span>
<span class="preprocessor">#include &quot;cppa/to_string.hpp&quot;</span>

<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::endl;

<span class="keyword">using namespace </span>cppa;

<span class="comment">// a node containing an integer and a vector of children</span>
<span class="keyword">struct </span>tree_node
{
    std::uint32_t value;
    std::vector&lt;tree_node&gt; children;

    tree_node(std::uint32_t v = 0) : value(v)
    {
    }

    tree_node&amp; add_child(<span class="keywordtype">int</span> v = 0)
    {
        children.push_back({ v });
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }

    tree_node(<span class="keyword">const</span> tree_node&amp;) = <span class="keywordflow">default</span>;

    <span class="comment">// recursively print this node and all of its children to stdout</span>
    <span class="keywordtype">void</span> print()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// format is: value { children0, children1, ..., childrenN }</span>
        <span class="comment">// e.g., 10 { 20 { 21, 22 }, 30 }</span>
        cout &lt;&lt; value;
        <span class="keywordflow">if</span> (children.empty() == <span class="keyword">false</span>)
        {
            cout &lt;&lt; <span class="stringliteral">&quot; { &quot;</span>;
            <span class="keyword">auto</span> begin = children.begin();
            <span class="keyword">auto</span> end = children.end();
            <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = begin; i != end; ++i)
            {
                <span class="keywordflow">if</span> (i != begin)
                {
                    cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
                }
                i-&gt;print();
            }
            cout &lt;&lt; <span class="stringliteral">&quot; } &quot;</span>;
        }
    }

};

<span class="comment">// a very primitive tree implementation</span>
<span class="keyword">struct </span>tree
{
    tree_node root;

    <span class="comment">// print tree to stdout</span>
    <span class="keywordtype">void</span> print()<span class="keyword"> const</span>
<span class="keyword">    </span>{
        cout &lt;&lt; <span class="stringliteral">&quot;tree::print: &quot;</span>;
        root.print();
        cout &lt;&lt; endl;
    }

};

<span class="comment">// tree nodes are equals if values and all values of all children are equal</span>
<span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> tree_node&amp; lhs, <span class="keyword">const</span> tree_node&amp; rhs)
{
    <span class="keywordflow">return</span> (lhs.value == rhs.value) &amp;&amp; (lhs.children == rhs.children);
}

<span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> tree&amp; lhs, <span class="keyword">const</span> tree&amp; rhs)
{
    <span class="keywordflow">return</span> lhs.root == rhs.root;
}

<span class="comment">// abstract_uniform_type_info implements all functions of uniform_type_info</span>
<span class="comment">// except for serialize() and deserialize() if the template parameter T:</span>
<span class="comment">// - does have a default constructor</span>
<span class="comment">// - does have a copy constructor</span>
<span class="comment">// - does provide operator==</span>
<span class="keyword">class </span>tree_type_info : <span class="keyword">public</span> util::abstract_uniform_type_info&lt;tree&gt;
{

 <span class="keyword">protected</span>:

    <span class="keywordtype">void</span> serialize(<span class="keyword">const</span> <span class="keywordtype">void</span>* ptr, <a name="_a0"></a><a class="code" href="classcppa_1_1serializer.html" title="Technology-independent serialization interface.">serializer</a>* sink)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// ptr is guaranteed to be a pointer of type tree</span>
        <span class="keyword">auto</span> tree_ptr = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>tree*<span class="keyword">&gt;</span>(ptr);
        <span class="comment">// serialization always begins with begin_object(name())</span>
        <span class="comment">// and ends with end_object();</span>
        <span class="comment">// name() returns the uniform type name of tree</span>
        sink-&gt;<a name="a1"></a><a class="code" href="classcppa_1_1serializer.html#ad87c5557dc2582f1df7e6c8770c49286" title="Begins serialization of an object of the type named type_name.">begin_object</a>(name());
        <span class="comment">// recursively serialize nodes, beginning with root</span>
        serialize_node(tree_ptr-&gt;root, sink);
        sink-&gt;<a name="a2"></a><a class="code" href="classcppa_1_1serializer.html#ab7d4c4dba33a86d3a86dd63d1d386ba0" title="Ends serialization of an object.">end_object</a>();
    }

    <span class="keywordtype">void</span> deserialize(<span class="keywordtype">void</span>* ptr, <a name="_a3"></a><a class="code" href="classcppa_1_1deserializer.html" title="Technology-independent deserialization interface.">deserializer</a>* source)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// seek_object() gets the uniform name of the next object in the</span>
        <span class="comment">// stream without modifying the deserializer</span>
        std::string cname = source-&gt;<a name="a4"></a><a class="code" href="classcppa_1_1deserializer.html#aac302b6a8c6e3f2c0006750968b7a975" title="Seeks the beginning of the next object and return its uniform type name.">seek_object</a>();
        <span class="comment">// this name has to be our type name</span>
        <span class="keywordflow">if</span> (cname != name())
        {
            <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;wrong type name found&quot;</span>);
        }
        <span class="comment">// ptr is guaranteed to be a pointer of type tree</span>
        <span class="keyword">auto</span> tree_ptr = <span class="keyword">reinterpret_cast&lt;</span>tree*<span class="keyword">&gt;</span>(ptr);
        tree_ptr-&gt;root.children.clear();
        <span class="comment">// workflow is analogous to serialize: begin_object() ... end_object()</span>
        source-&gt;<a name="a5"></a><a class="code" href="classcppa_1_1deserializer.html#a0dd429dbb1e6e5410e907a0727e2e26d" title="Begins deserialization of an object of type type_name.">begin_object</a>(cname);
        <span class="comment">// recursively deserialize nodes, beginning with root</span>
        deserialize_node(tree_ptr-&gt;root, source);
        source-&gt;<a name="a6"></a><a class="code" href="classcppa_1_1deserializer.html#ab74eee91442d5f3fd979bbaea7036769" title="Ends deserialization of an object.">end_object</a>();
    }

 <span class="keyword">private</span>:

    <span class="keywordtype">void</span> serialize_node(<span class="keyword">const</span> tree_node&amp; node, <a class="code" href="classcppa_1_1serializer.html" title="Technology-independent serialization interface.">serializer</a>* sink)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// value, ... children ...</span>
        sink-&gt;<a name="a7"></a><a class="code" href="classcppa_1_1serializer.html#a2eb2aa15e5e772f570f56e9ae7c5eeae" title="Writes a single value to the data sink.">write_value</a>(node.value);
        sink-&gt;<a name="a8"></a><a class="code" href="classcppa_1_1serializer.html#a5ff6beb06c8bb85de11fdfb33f0ea0aa" title="Begins serialization of a sequence of size num.">begin_sequence</a>(node.children.size());
        <span class="keywordflow">for</span> (<span class="keyword">const</span> tree_node&amp; subnode : node.children)
        {
            serialize_node(subnode, sink);
        }
        sink-&gt;<a name="a9"></a><a class="code" href="classcppa_1_1serializer.html#a8c4e725095d8d51826f1ebc95e8b738a" title="Ends serialization of a sequence.">end_sequence</a>();
    }

    <span class="keywordtype">void</span> deserialize_node(tree_node&amp; node, <a class="code" href="classcppa_1_1deserializer.html" title="Technology-independent deserialization interface.">deserializer</a>* source)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// value, ... children ...</span>
        <span class="keyword">auto</span> value = get&lt;std::uint32_t&gt;(source-&gt;<a name="a10"></a><a class="code" href="classcppa_1_1deserializer.html#a3cdf810f985cd64a0d429b1f28e203ca" title="Reads a primitive value from the data source of type ptype.">read_value</a>(<a name="a11"></a><a class="code" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a081be63f60008807f9a07df1d814704a">pt_uint32</a>));
        node.value = value;
        <span class="keyword">auto</span> num_children = source-&gt;<a name="a12"></a><a class="code" href="classcppa_1_1deserializer.html#ab7342c6023ac82b8fc2e1c90db265f93" title="Begins deserialization of a sequence.">begin_sequence</a>();
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; num_children; ++i)
        {
            node.add_child();
            deserialize_node(node.children.back(), source);
        }
        source-&gt;<a name="a13"></a><a class="code" href="classcppa_1_1deserializer.html#ad8b4ae56320e117ad03344d446e0cb6d" title="Ends deserialization of a sequence.">end_sequence</a>();
    }

};

<span class="keywordtype">int</span> main()
{
    <span class="comment">// the tree_type_info is owned by libcppa after this function call</span>
    <a name="a14"></a><a class="code" href="group___type_system.html#ga7f73c466e0356b08161d77769aeb726f" title="Adds a new type mapping to the libcppa type system.">announce</a>(<span class="keyword">typeid</span>(tree), <span class="keyword">new</span> tree_type_info);

    tree t; <span class="comment">// create a tree and fill it with some data</span>

    t.root.add_child(10);
    t.root.children.back().add_child(11).add_child(12).add_child(13);

    t.root.add_child(20);
    t.root.children.back().add_child(21).add_child(22);

    <span class="comment">/*</span>
<span class="comment">        tree t is now:</span>
<span class="comment">               0</span>
<span class="comment">              / \</span>
<span class="comment">             /   \</span>
<span class="comment">            /     \</span>
<span class="comment">          10       20</span>
<span class="comment">         / |\     /  \</span>
<span class="comment">        /  | \   /    \</span>
<span class="comment">       11 12 13 21    22</span>
<span class="comment">    */</span>

    <span class="comment">// send a tree to ourselves ...</span>
    <a name="a15"></a><a class="code" href="namespacecppa.html#a1e0690c8df96f321e39dd8cac1269e7f" title="Sends a message to whom.">send</a>(<span class="keyword">self</span>(), t);

    <span class="comment">// send a vector of trees to ourselves</span>
    <span class="keyword">typedef</span> std::vector&lt;tree&gt; tree_vector;
    announce&lt;tree_vector&gt;();
    tree_vector tvec;
    tvec.push_back(t);
    tvec.push_back(t);
    <a class="code" href="namespacecppa.html#a1e0690c8df96f321e39dd8cac1269e7f" title="Sends a message to whom.">send</a>(<span class="keyword">self</span>(), tvec);

    <span class="comment">// receive both messages</span>
    <span class="keywordtype">int</span> i = 0;
    <a name="a16"></a><a class="code" href="namespacecppa.html#a04248d8185833939eccbf45a0598fff7" title="Receives messages as long as stmt returns true.">receive_while</a>([&amp;]() { <span class="keywordflow">return</span> ++i &lt;= 2; })
    (
        <span class="comment">// ... and receive it</span>
        on&lt;tree&gt;() &gt;&gt; [](<span class="keyword">const</span> tree&amp; tmsg)
        {
            <span class="comment">// prints the tree in its serialized format:</span>
            <span class="comment">// @&lt;&gt; ( { tree ( 0, { 10, { 11, { }, 12, { }, 13, { } }, 20, { 21, { }, 22, { } } } ) } )</span>
            cout &lt;&lt; <span class="stringliteral">&quot;to_string(last_received()): &quot;</span>
                 &lt;&lt; to_string(<a name="a17"></a><a class="code" href="namespacecppa.html#abf2fc4e0570df2765d49fd80cee410c9" title="Gets the last dequeued message from the mailbox.">last_received</a>())
                 &lt;&lt; endl;
            <span class="comment">// prints the tree using the print member function:</span>
            <span class="comment">// 0 { 10 { 11, 12, 13 } , 20 { 21, 22 } }</span>
            tmsg.print();
        },
        on&lt;tree_vector&gt;() &gt;&gt; [](<span class="keyword">const</span> tree_vector&amp; trees)
        {
            <span class="comment">// prints &quot;received 2 trees&quot;</span>
            cout &lt;&lt; <span class="stringliteral">&quot;received &quot;</span> &lt;&lt; trees.size() &lt;&lt; <span class="stringliteral">&quot; trees&quot;</span> &lt;&lt; endl;
            <span class="comment">// prints:</span>
            <span class="comment">// @&lt;&gt; ( {</span>
            <span class="comment">//   std::vector&lt;tree,std::allocator&lt;tree&gt;&gt; ( {</span>
            <span class="comment">//     tree ( 0, { 10, { 11, { }, 12, { }, 13, { } }, 20, { 21, { }, 22, { } } } ),</span>
            <span class="comment">//     tree ( 0, { 10, { 11, { }, 12, { }, 13, { } }, 20, { 21, { }, 22, { } } } )</span>
            <span class="comment">//   )</span>
            <span class="comment">// } )</span>
            cout &lt;&lt; <span class="stringliteral">&quot;to_string: &quot;</span> &lt;&lt; to_string(<a class="code" href="namespacecppa.html#abf2fc4e0570df2765d49fd80cee410c9" title="Gets the last dequeued message from the mailbox.">last_received</a>()) &lt;&lt; endl;
        }
    );

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 7 2011 23:30:24 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
